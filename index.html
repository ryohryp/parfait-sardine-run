<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒ‘ãƒ•ã‚§ã¨ã‚¤ãƒ¯ã‚· RUN! â€“ Character Gacha EX</title>
<style>
  :root { --maxw: 920px; }
  * { box-sizing: border-box; }
  body{margin:0;background:#eaf1f8;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;color:#222;text-align:center}
  header{padding:12px 8px 4px}
  #playerNameBar{display:flex;justify-content:center;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap;font-size:14px}
  #playerNameLabel{font-weight:600}
  .smallBtn{padding:6px 12px;font-size:13px}
  h1{margin:0 0 6px;font-size:clamp(20px,4vw,28px)}
  #hud{
    font-size:clamp(13px,3.2vw,18px);
    margin:0 auto 12px;
    max-width:var(--maxw);
    display:flex;
    flex-direction:column;
    gap:6px;
    text-align:left;
    background:rgba(255,255,255,.85);
    color:#111827;
    border-radius:12px;
    padding:10px 14px;
    box-shadow:0 6px 22px rgba(15,23,42,.12);
  }
  .hudRow{display:flex;flex-wrap:wrap;gap:8px 16px;align-items:center}
  .hudItem{display:inline-flex;align-items:center;gap:6px;line-height:1.4}
  .hudItem strong{font-size:.78em;letter-spacing:.08em;color:#2563eb;text-transform:uppercase}
  .hudItem .value{font-weight:600}
  .hudTag{display:inline-flex;align-items:center;padding:2px 8px;background:#facc15;color:#111827;border-radius:999px;font-size:.75em;font-weight:600}
  .hudHearts{font-size:1.05em}
  .hudCoins{gap:4px}
  #wrap{max-width:var(--maxw);margin:0 auto;padding:8px}
  canvas{width:100%;height:auto;max-width:var(--maxw);background:linear-gradient(#9ed6ee,#fff7e6);border:2px solid #333;border-radius:12px;touch-action:none}
  #btns{display:flex;gap:8px;justify-content:center;margin:10px 0;flex-wrap:wrap}
  button{appearance:none;border:0;border-radius:10px;padding:10px 16px;font-size:16px;background:#22c55e;color:#fff;box-shadow:0 2px 0 rgba(0,0,0,.2)}
  button.secondary{background:#3b82f6}
  button.ghost{background:#6b7280}
  button.warn{background:#ef4444}
  button:disabled{opacity:.5}
  .muted{opacity:.75}
  .controls{max-width:var(--maxw);margin:0 auto;line-height:1.6;text-align:left}
  #objective{
    max-width:var(--maxw);
    margin:0 auto 14px;
    text-align:left;
    background:#111827;
    color:#f9fafb;
    border-radius:16px;
    padding:14px 18px;
    box-shadow:0 14px 28px rgba(15,23,42,.28);
  }
  #objective h2{margin:0 0 6px;font-size:clamp(18px,3.2vw,24px)}
  #objective p{margin:0 0 8px;line-height:1.65}
  #objective ul{margin:0;padding-left:22px;display:grid;gap:4px;font-size:clamp(12px,3.2vw,16px)}
  #objective li::marker{color:#facc15}
  #objective strong{color:#fbbf24}
  #ultBtn{
    position: fixed; right: 14px; bottom: 18px; z-index: 10;
    padding:12px 16px; border-radius:14px; background:#ef4444; color:#fff; font-weight:700;
    box-shadow:0 3px 0 rgba(0,0,0,.25); user-select:none;
  }
  @media(hover:hover){ #ultBtn:hover{ filter:brightness(1.05); } }

  /* ã‚¬ãƒãƒ£ & ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
  .overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; z-index:20;
    align-items:center; justify-content:center; padding:16px;
  }
  .cardWrap{
    width:min(94vw,820px); background:#111827; color:#fff; border-radius:16px; padding:16px;
    box-shadow:0 8px 32px rgba(0,0,0,.45); text-align:left;
  }
  .cardHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .cardHeader h2{margin:0;font-size:20px}
  .cardBody{min-height:160px;border:1px solid #374151;border-radius:12px;padding:12px;background:#0b1220}
  .grid{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
  .miniCard{
    border-radius:12px; padding:10px; text-align:center; min-height:84px;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08); cursor:pointer;
  }
  .rankList{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:6px}
  .rankList li{display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.08);padding:8px 12px;border-radius:10px;font-size:14px}
  .rankList li .rankMeta{font-size:12px;opacity:.8;margin-top:2px}
  .rankList li .rankScore{font-size:18px;font-weight:700;margin-left:16px}
  .rankLeft{display:flex;flex-direction:column;align-items:flex-start;gap:2px}
  .rankHeader{display:flex;align-items:center;gap:10px;font-weight:600}
  .rankNo{display:inline-block;min-width:24px;text-align:center;font-size:16px;font-weight:700;background:rgba(0,0,0,.2);padding:2px 6px;border-radius:999px}
  .rankEmpty{list-style:none;padding:18px 0;text-align:center;opacity:.65}
  .howList{display:grid;gap:8px;margin:12px 0 0;padding-left:20px;line-height:1.6}
  .howList li::marker{color:#3b82f6;font-weight:700}
  .howLead{margin:8px 0 0;line-height:1.6}
  .howFooter{display:flex;flex-wrap:wrap;align-items:center;justify-content:space-between;gap:12px;margin-top:16px}
  .howFooterNote{font-size:13px;opacity:.75}
  .rar-c{background:#111827}
  .rar-r{background:linear-gradient(135deg,#1f2937,#0ea5e9)}
  .rar-e{background:linear-gradient(135deg,#3b0764,#a21caf)}
  .rar-l{background:linear-gradient(135deg,#7c2d12,#f59e0b)}
  .rar-m{background:linear-gradient(135deg,#16213e,#22d3ee)}
  .big{font-size:28px}
  .small{font-size:12px;opacity:.85}
  .footerBtns{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}

  /* å³ä¸Šã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
  #charInfo{position:fixed; right:12px; top:8px; font-size:12px; background:rgba(0,0,0,.5); color:#fff; padding:6px 10px; border-radius:10px}
</style>
</head>
<body>
  <header>
    <h1>ãƒ‘ãƒ•ã‚§ã¨ã‚¤ãƒ¯ã‚· RUN! â€“ Character Gacha EX</h1>
    <div id="playerNameBar">
      <span id="playerNameLabel" class="muted">ãƒ¦ãƒ¼ã‚¶ãƒ¼åæœªè¨­å®š</span>
      <button id="editName" class="ghost smallBtn">ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®š</button>
    </div>
    <div id="hud" class="muted">èª­ã¿è¾¼ã¿ä¸­â€¦</div>
    <div id="charInfo" class="muted">CHAR: -</div>
  </header>

  <section id="objective">
    <h2>ã‚²ãƒ¼ãƒ ã®ç›®çš„</h2>
    <p>ä»¤å’Œã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒ©ãƒ³ï¼†ã‚·ãƒ¥ãƒ¼ãƒˆã§ã€<strong>60ç§’ä»¥å†…ã«ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’å©ãå‡ºã—</strong>ã¤ã¤ã‚³ã‚¤ãƒ³ã‚’ç¨¼ãã€ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¢—ã‚„ã—ã¾ã—ã‚‡ã†ã€‚</p>
    <ul>
      <li><strong>ã‚¢ã‚¤ãƒ†ãƒ ã‚’é›†ã‚ã¦</strong>ã‚¹ã‚³ã‚¢ã¨ã‚³ã‚¤ãƒ³ã‚’ç²å¾—ã€‚é›†ã‚ãŸã‚³ã‚¤ãƒ³ã§ã‚¬ãƒãƒ£ã‚’å›ã—ã€æ–°ã—ã„ã‚­ãƒ£ãƒ©ã‚’é–‹æ”¾ï¼</li>
      <li><strong>ã‚¸ãƒ£ãƒ³ãƒ—ã¨æ”»æ’ƒã§æ•µã‚’ã‹ã‚ã—ã¤ã¤æ’ƒç ´</strong>ã€‚é€£ç¶šãƒ’ãƒƒãƒˆã§ã‚¹ã‚³ã‚¢ãŒãã‚“ãã‚“ä¼¸ã³ã¾ã™ã€‚</li>
      <li><strong>å¿…æ®ºæŠ€ã‚²ãƒ¼ã‚¸ãŒ100%ã«ãªã£ãŸã‚‰ä¸€æ°—ã«åæ’ƒ</strong>ã€‚ã‚­ãƒ£ãƒ©å›ºæœ‰ã®ã‚¹ã‚­ãƒ«ã‚’æ´»ã‹ã—ã¦ãƒã‚¤ã‚¹ã‚³ã‚¢ã‚’ç‹™ã„ã¾ã—ã‚‡ã†ã€‚</li>
    </ul>
  </section>

  <div id="wrap">
    <canvas id="cv" width="900" height="430"></canvas>
    <div id="btns">
      <button id="start">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="restart" class="secondary" style="display:none">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="howto" class="ghost">éŠã³æ–¹</button>
      <button id="gachaOpen" class="warn" disabled>ã‚¬ãƒãƒ£(10)</button>
      <button id="gacha10" class="warn" disabled>10é€£(100)</button>
      <button id="collection" class="ghost">ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</button>
      <button id="ranking" class="ghost">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
    </div>
    <p class="muted controls"><strong>æ“ä½œãƒ’ãƒ³ãƒˆï¼š</strong>ç”»é¢å·¦å´ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ï¼ã‚¸ãƒ£ãƒ³ãƒ—ã€å³å´ï¼æ”»æ’ƒã€å³é•·æŠ¼ã— or å³ä¸‹ã®<strong>å¿…æ®º</strong>ãƒœã‚¿ãƒ³ï¼å¿…æ®ºæŠ€ï¼ˆã‚²ãƒ¼ã‚¸100%æ™‚ï¼‰ã€‚</p>
  </div>

  <button id="ultBtn" style="display:none">å¿…æ®º</button>

  <!-- éŠã³æ–¹ -->
  <div id="howOverlay" class="overlay">
    <div class="cardWrap">
      <div class="cardHeader">
        <h2>éŠã³æ–¹ã‚¬ã‚¤ãƒ‰</h2>
        <button id="howClose" class="ghost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="cardBody">
        <p id="howLead" class="howLead">60ç§’ã§ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ã—ã€ã‚³ã‚¤ãƒ³ã§ã‚¬ãƒãƒ£ã‚’è§£æ”¾ã—ã¦ã‚­ãƒ£ãƒ©å›³é‘‘ã‚’å……å®Ÿã•ã›ã¾ã—ã‚‡ã†ã€‚</p>
        <ul class="howList">
          <li>ç”»é¢å·¦ã‚¿ãƒƒãƒ—/ã‚¯ãƒªãƒƒã‚¯ã§ã‚¸ãƒ£ãƒ³ãƒ—ã€‚äºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—å¯èƒ½ãªã‚­ãƒ£ãƒ©ã‚‚ã„ã¾ã™ã€‚</li>
          <li>ç”»é¢å³ã‚¿ãƒƒãƒ—ã§æ”»æ’ƒã€é•·æŠ¼ã— or å³ä¸‹ã®<strong>å¿…æ®º</strong>ãƒœã‚¿ãƒ³ã§ã‚²ãƒ¼ã‚¸100%æ™‚ã®å¿…æ®ºæŠ€ã‚’ç™ºå‹•ã€‚</li>
          <li>ğŸ¨ã‚„ğŸŸã‚¢ã‚¤ãƒ†ãƒ ã§ã‚¹ã‚³ã‚¢ï¼†ã‚³ã‚¤ãƒ³ã€â­ã§ç„¡æ•µã¨ã‚²ãƒ¼ã‚¸UPã€‚æ•µã‚’å€’ã™ã¨ã•ã‚‰ã«ãƒœãƒ¼ãƒŠã‚¹ã€‚</li>
          <li>é›†ã‚ãŸã‚³ã‚¤ãƒ³ã§ã‚¬ãƒãƒ£ã‚’å›ã—ã€ã‚­ãƒ£ãƒ©ã‚’è£…å‚™ã—ã¦èƒ½åŠ›ã‚’å…¥ã‚Œæ›¿ãˆã¾ã—ã‚‡ã†ã€‚</li>
        </ul>
      </div>
      <div class="howFooter">
        <span class="howFooterNote">ãƒ’ãƒ³ãƒˆï¼šãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯è‡ªå‹•ã§ä¿å­˜ã€‚é€£ç¶šãƒ—ãƒ¬ã‚¤ã§ä»¤å’Œãƒãƒ£ãƒ³ãƒ—ã‚’ç›®æŒ‡ãã†ï¼</span>
        <button id="howStart" class="secondary">ä»Šã™ããƒ—ãƒ¬ã‚¤</button>
      </div>
    </div>
  </div>

  <!-- ã‚¬ãƒãƒ£ -->
  <div id="gachaOverlay" class="overlay">
    <div class="cardWrap">
      <div class="cardHeader">
        <h2>ã‚¬ãƒãƒ£çµæœ</h2>
        <button id="gachaClose" class="ghost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="cardBody">
        <div id="gachaResults" class="grid"></div>
      </div>
      <div class="footerBtns">
        <button id="pull1" class="warn">ã‚‚ã†ä¸€åº¦(10)</button>
        <button id="pull10" class="warn">10é€£(100)</button>
      </div>
    </div>
  </div>

  <!-- ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ -->
  <div id="colOverlay" class="overlay">
    <div class="cardWrap">
      <div class="cardHeader">
        <h2>ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚¿ãƒƒãƒ—ã§é¸æŠï¼‰</h2>
        <button id="colClose" class="ghost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="cardBody">
        <div id="colGrid" class="grid"></div>
      </div>
      <div class="footerBtns">
        <button id="colEquip" class="secondary" disabled>ã“ã®ã‚­ãƒ£ãƒ©ã‚’è£…å‚™</button>
      </div>
    </div>
  </div>

  <!-- ãƒ©ãƒ³ã‚­ãƒ³ã‚° -->
  <div id="rankOverlay" class="overlay">
    <div class="cardWrap">
      <div class="cardHeader">
        <h2>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
        <button id="rankClose" class="ghost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="cardBody">
        <ol id="rankList" class="rankList"></ol>
      </div>
      <div class="footerBtns">
        <button id="rankRefresh" class="ghost">æœ€æ–°ã«æ›´æ–°</button>
      </div>
    </div>
  </div>

  <!-- ãƒ¦ãƒ¼ã‚¶ãƒ¼åè¨­å®š -->
  <div id="nameOverlay" class="overlay">
    <div class="cardWrap">
      <div class="cardHeader">
        <h2>ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®š</h2>
        <button id="nameClose" class="ghost">é–‰ã˜ã‚‹</button>
      </div>
      <div class="cardBody">
        <p style="margin-top:0;font-size:14px;line-height:1.5">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«è¡¨ç¤ºã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚2ã€œ16æ–‡å­—ã€çµµæ–‡å­—ã‚‚åˆ©ç”¨ã§ãã¾ã™ã€‚</p>
        <input id="nameInput" type="text" maxlength="24" style="width:100%;padding:10px;border-radius:8px;border:1px solid #374151;font-size:16px" placeholder="ä¾‹ï¼‰ãƒ‘ãƒ•ã‚§ãƒã‚¹ã‚¿ãƒ¼" />
        <p id="nameError" style="color:#f87171;font-size:13px;min-height:18px;margin:6px 0 0"></p>
      </div>
      <div class="footerBtns">
        <button id="nameSave" class="secondary">ä¿å­˜</button>
      </div>
    </div>
  </div>


<script>
(()=>{
// ====== åŸºæœ¬ ======
const cv = document.getElementById('cv');
const c = cv.getContext('2d');
const hud = document.getElementById('hud');
const btnStart = document.getElementById('start');
const btnRestart = document.getElementById('restart');
const btnHow = document.getElementById('howto');
const btnUlt = document.getElementById('ultBtn');
const btnGacha = document.getElementById('gachaOpen');
const btnGacha10 = document.getElementById('gacha10');
const btnCollection = document.getElementById('collection');
const btnRanking = document.getElementById('ranking');
const playerNameLabel = document.getElementById('playerNameLabel');
const btnEditName = document.getElementById('editName');
const charInfo = document.getElementById('charInfo');
const howOverlay = document.getElementById('howOverlay');
const howClose = document.getElementById('howClose');
const howStart = document.getElementById('howStart');
const howLead = document.getElementById('howLead');

// ã‚¬ãƒãƒ£UI
const ov = document.getElementById('gachaOverlay');
const resWrap = document.getElementById('gachaResults');
document.getElementById('gachaClose').onclick = ()=> ov.style.display='none';
document.getElementById('pull1').onclick = ()=> doGacha(1);
document.getElementById('pull10').onclick = ()=> doGacha(10);

// ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³UI
const colOv = document.getElementById('colOverlay');
const colGrid = document.getElementById('colGrid');
const colClose = document.getElementById('colClose');
const colEquip = document.getElementById('colEquip');
let colSelectedKey = null;
colClose.onclick = ()=>{ colOv.style.display='none'; colSelectedKey=null; colEquip.disabled=true; };
colEquip.onclick = ()=>{ if(colSelectedKey){ setCurrentChar(colSelectedKey); colOv.style.display='none'; } };

// ãƒ©ãƒ³ã‚­ãƒ³ã‚°UI
const rankOv = document.getElementById('rankOverlay');
const rankList = document.getElementById('rankList');
const rankClose = document.getElementById('rankClose');
const rankRefreshBtn = document.getElementById('rankRefresh');

// ãƒ¦ãƒ¼ã‚¶ãƒ¼å UI
const nameOv = document.getElementById('nameOverlay');
const nameClose = document.getElementById('nameClose');
const nameInput = document.getElementById('nameInput');
const nameError = document.getElementById('nameError');
const nameSave = document.getElementById('nameSave');

function openHowto(initial=false){
  if (!howOverlay) return;
  if (howLead){
    howLead.textContent = initial
      ? 'ã¾ãšã¯æ“ä½œã‚’ãƒã‚§ãƒƒã‚¯ï¼60ç§’ãƒ©ãƒ³ã§ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’ç‹™ã„ã€ã‚³ã‚¤ãƒ³ã§ã‚­ãƒ£ãƒ©ã‚’é›†ã‚ã¾ã—ã‚‡ã†ã€‚'
      : 'å›°ã£ãŸã‚‰ã„ã¤ã§ã‚‚ã“ã“ã§æ“ä½œã¨ç›®çš„ã‚’ç¢ºèªã§ãã¾ã™ã€‚';
  }
  howOverlay.style.display='flex';
}

if (btnHow){
  btnHow.addEventListener('click', ()=> openHowto(false));
}
if (howClose){
  howClose.addEventListener('click', ()=>{ howOverlay.style.display='none'; });
}
if (howStart){
  howStart.addEventListener('click', ()=>{
    howOverlay.style.display='none';
    if (!gameOn) startGame();
  });
}
const INTRO_KEY = 'psrun_intro_seen_v2';
try{
  if (!localStorage.getItem(INTRO_KEY)){
    openHowto(true);
    localStorage.setItem(INTRO_KEY,'1');
  }
}catch{
  openHowto(true);
}

// ç‰©ç† & ã‚²ãƒ¼ãƒ åŸºæœ¬
const G = 0.62, BASE_JUMP = -12.2, GROUND = 72;
const GAME_TIME = 60000;

let gameOn=false, t0=0;
let lastItem=0, lastEnemy=0, lastPower=0, lastShot=0;
let score=0, level=1, lives=3, invUntil=0, hurtUntil=0;
let ult=0, ultReady=false, ultActiveUntil=0;
let coins=0; // ã‚¬ãƒãƒ£ç”¨
let autoShootUntil=0, bulletBoostUntil=0, scoreMulUntil=0;

const shootCD=250, powerMillis=6000, enemyBonus=3, itemLv=15;
const player = { x:120, y:cv.height-GROUND-46, w:46, h:46, vy:0, onGround:true, color:'#ff6347' };

let items=[], enemies=[], bullets=[], powers=[], ultProjectiles=[];

// ã‚¹ãƒ†ãƒ¼ã‚¸
const stages = [
  { name:'è‰åŸ',  bg1:'#9ed6ee', bg2:'#fff7e6', ground:'#7fb10a', enemyMul:1.00 },
  { name:'ç ‚æ¼ ',  bg1:'#ffd28a', bg2:'#ffe9c7', ground:'#d2a659', enemyMul:1.10 },
  { name:'é›ªåŸ',  bg1:'#c8e7ff', bg2:'#f6fbff', ground:'#b9d3e5', enemyMul:1.22 },
  { name:'å®‡å®™',  bg1:'#0b1833', bg2:'#1b2850', ground:'#0b1833', enemyMul:1.38 },
];
function stageForLevel(lv){
  if (lv>=10) return stages[3];
  if (lv>=7)  return stages[2];
  if (lv>=4)  return stages[1];
  return stages[0];
}

// ====== ã‚­ãƒ£ãƒ©å®šç¾© ======
/*
  å„å€¤ã¯å€ç‡/ãƒŸãƒªç§’ã€‚
  special: ['magnet','oneGuard','doubleJump','pierce']
  ult: 'rainbow' | 'storm' | 'ncha' | 'yadon' | null
*/
const characters = {
  // Common
  parfen:   { key:'parfen',   name:'ğŸ“ãƒ‘ãƒ•ã‚§ãƒ³',    emoji:'ğŸ“', rar:'C', move:1.00, jump:1.00, bullet:1.00, inv:6000, ultRate:1.00, special:[],             ult:null },
  iwassy:   { key:'iwassy',   name:'ğŸŸã‚¤ãƒ¯ãƒƒã‚·ãƒ¼',  emoji:'ğŸŸ', rar:'C', move:1.00, jump:1.10, bullet:1.00, inv:6000, ultRate:1.00, special:['airAttack'], ult:null },

  // Rare
  choco:    { key:'choco',    name:'ğŸ«ãƒãƒ§ã‚³ãƒ‘ãƒ•ã‚§ãƒ³', emoji:'ğŸ«', rar:'R', move:1.00, jump:1.00, bullet:1.15, inv:7000, ultRate:1.00, special:[],           ult:null },
  missile:  { key:'missile',  name:'ğŸš€ãƒŸã‚µã‚¤ãƒ«å›',   emoji:'ğŸš€', rar:'R', move:1.10, jump:1.00, bullet:1.00, inv:6000, ultRate:1.05, special:[],           ult:null },

  // Epic
  ice:      { key:'ice',      name:'â„ï¸ã‚¢ã‚¤ã‚¹çš‡å¸',  emoji:'â„ï¸', rar:'E', move:1.00, jump:1.20, bullet:1.00, inv:6000, ultRate:1.00, special:['slowEnemy'], ult:null },

  // Legendary
  king:     { key:'king',     name:'ğŸ‘‘ã‚­ãƒ³ã‚°ãƒ‘ãƒ•ã‚§', emoji:'ğŸ‘‘', rar:'L', move:1.15, jump:1.10, bullet:1.10, inv:7000, ultRate:1.20, special:[], ult:'rainbow' },
  ncha:     { key:'ncha',     name:'ğŸ¤–ã‚“ã¡ã‚ƒãƒã‚·ãƒ³', emoji:'ğŸ¤–', rar:'L', move:1.20, jump:1.05, bullet:1.25, inv:6800, ultRate:1.25, special:['pierce'], ult:'ncha' },

  // Mythic
  aurora:   { key:'aurora',   name:'ğŸŒˆã‚ªãƒ¼ãƒ­ãƒ©ãƒ‘ãƒ•ã‚§', emoji:'ğŸŒˆ', rar:'M', move:1.18, jump:1.12, bullet:1.15, inv:8000, ultRate:1.35, special:['magnet','oneGuard'], ult:'rainbow' },
  iwashiK:  { key:'iwashiK',  name:'ğŸŒ€ãƒˆãƒ«ãƒãƒ¼ãƒ‰é°¯ç‹', emoji:'ğŸŒ€', rar:'M', move:1.15, jump:1.20, bullet:1.10, inv:7000, ultRate:1.30, special:['doubleJump','pierce'], ult:'storm' },
  yadon:    { key:'yadon',    name:'ğŸ¦›ã¾ã£ãŸã‚Šãƒ¤ãƒ‰ãƒ³', emoji:'ğŸ¦›', rar:'M', move:0.98, jump:1.08, bullet:1.05, inv:8500, ultRate:1.45, special:['magnet'], ult:'yadon' },
};

// ãƒ¬ã‚¢â†’ã‚«ãƒ©ãƒ¼/é †åº
const rarOrder = ['C','R','E','L','M'];
function rarClass(r){ return r==='M'?'rar-m':r==='L'?'rar-l':r==='E'?'rar-e':r==='R'?'rar-r':'rar-c'; }

// æ‰€æŒãƒ‡ãƒ¼ã‚¿ï¼ˆlocalStorageï¼‰
const STORE_KEY = 'psrun_char_collection_v1';
const USERNAME_KEY = 'psrun_username_v1';
const RANK_MAX = 20;
const DEFAULT_API_BASE = '/api';
const API_BASE = (typeof window.PSRUN_API_BASE === 'string' && window.PSRUN_API_BASE.trim().length > 0)
  ? window.PSRUN_API_BASE.trim()
  : DEFAULT_API_BASE;
let collection = loadCollection();
let currentCharKey = collection.current || 'parfen';
if(!collection.owned[currentCharKey]) {
  // åˆå›ã¯ãƒ‘ãƒ•ã‚§ãƒ³ä»˜ä¸
  collection.owned.parfen = { owned:true, dup:0, limit:0 };
  saveCollection();
  currentCharKey = 'parfen';
}
updateCharInfo();
let username = loadUsername();
let rankings = [];
let isRankingLoading = false;
let rankingError = '';
updateNameUI();
if (!username) openNameModal();
refreshLeaderboard();

// ====== ã‚¬ãƒãƒ£ï¼šç¢ºç‡ & å¤©äº• ======
/*
  ç¢ºç‡ï¼šC60/R24/E10/L5/M1
  å¤©äº•ï¼š30é€£ã§Lä»¥ä¸Šä¿è¨¼ / 100é€£ã§Mä¿è¨¼
*/
const pityKey = 'psrun_pity_v1';
let pity = loadPity(); // {sinceL:0, sinceM:0}

function rollRarity(){
  const p = Math.random();
  if (p < 0.01) return 'M';
  if (p < 0.06) return 'L';
  if (p < 0.16) return 'E';
  if (p < 0.40) return 'R';
  return 'C';
}
function rollCharByRar(r){
  const pool = Object.values(characters).filter(c=>c.rar===r);
  return pool[Math.floor(Math.random()*pool.length)];
}
function doGacha(n){
  const cost = n===10?100:10;
  if (coins<cost) return;
  coins -= cost;

  // ä¿éšœé©ç”¨ã®ãŸã‚ã€çµæœé…åˆ—ã‚’å…ˆã«ãƒ¬ã‚¢ã ã‘æ±ºã‚ã‚‹
  let rarities = [];
  for(let i=0;i<n;i++){
    let r = rollRarity();
    // 30é€£Lä¿éšœï¼ˆsinceL>=29 ã§æ¬¡ã¯Lä»¥ä¸Šä¿è¨¼ï¼‰
    if (pity.sinceL >= 29 && i===0) r = (Math.random()<0.167)?'M':'L';
    rarities.push(r);
  }
  // 100é€£Mä¿éšœï¼ˆsinceM>=99 ã§æœ€å¾Œã‚’Mã«ï¼‰
  if (pity.sinceM >= 99) rarities[rarities.length-1] = 'M';

  // çµæœç”Ÿæˆ
  const results = rarities.map(r=>{
    const ch = rollCharByRar(r);
    addToCollection(ch.key);
    // pityæ›´æ–°
    if (r==='M') { pity.sinceM=0; pity.sinceL=0; }
    else if (r==='L') { pity.sinceL=0; pity.sinceM++; }
    else { pity.sinceL++; pity.sinceM++; }
    return ch;
  });
  savePity();
  setHUD(GAME_TIME-(now()-t0));

  // è¡¨ç¤º
  resWrap.innerHTML='';
  resWrap.style.gridTemplateColumns = `repeat(${Math.min(5,results.length)},1fr)`;
  results.forEach(ch=>{
    const dv=document.createElement('div');
    dv.className=`miniCard ${rarClass(ch.rar)}`;
    const own = collection.owned[ch.key];
    dv.innerHTML = `<div class="big">${ch.emoji}</div>
      <div>${ch.name}</div>
      <div class="small">R:${ch.rar} / LB:${own.limit}</div>`;
    dv.onclick = ()=>{ setCurrentChar(ch.key); ov.style.display='none'; };
    resWrap.appendChild(dv);
  });
  ov.style.display='flex';
}

function addToCollection(key){
  if (!collection.owned[key]) collection.owned[key] = { owned:true, dup:0, limit:0 };
  else {
    collection.owned[key].dup++;
    // é™ç•Œçªç ´ãƒ«ãƒ¼ãƒ«ï¼ˆè¢«ã‚Šå¼·åŒ–ï¼‰
    const rar = characters[key].rar;
    const inc = rar==='M' ? 0.04 : rar==='L' ? 0.03 : rar==='E' ? 0.025 : rar==='R' ? 0.015 : 0.005;
    collection.owned[key].limit = +(collection.owned[key].limit + inc).toFixed(3); // å°æ•°ã§è“„ç©
  }
  saveCollection();
}

// ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³UI
btnCollection.onclick = ()=>{
  colGrid.innerHTML='';
  // ã‚½ãƒ¼ãƒˆï¼šãƒ¬ã‚¢â†’æ‰€æŒâ†’åå‰
  const list = Object.values(characters).sort((a,b)=>{
    const ra = rarOrder.indexOf(a.rar), rb = rarOrder.indexOf(b.rar);
    if (ra!==rb) return ra-rb;
    const oa = !!collection.owned[a.key], ob = !!collection.owned[b.key];
    if (oa!==ob) return (ob?1:-1);
    return a.name.localeCompare(b.name,'ja');
  });
  list.forEach(ch=>{
    const own = collection.owned[ch.key];
    const dv=document.createElement('div');
    dv.className=`miniCard ${rarClass(ch.rar)}`;
    dv.innerHTML = `<div class="big">${ch.emoji}</div>
      <div>${ch.name}</div>
      <div class="small">${own?`R:${ch.rar} / LB:${own.limit||0}`:'æœªæ‰€æŒ'}</div>`;
    dv.onclick = ()=>{
      colSelectedKey = ch.key;
      colEquip.disabled = !own;
      // è»½ã„é¸æŠãƒã‚¤ãƒ©ã‚¤ãƒˆ
      [...colGrid.children].forEach(x=>x.style.outline='none');
      dv.style.outline='2px solid #fff';
    };
    colGrid.appendChild(dv);
  });
  colOv.style.display='flex';
};

btnEditName.onclick = ()=>{ openNameModal(); };
nameClose.onclick = ()=>{ closeNameModal(); };
nameOv.addEventListener('click', (e)=>{ if(e.target===nameOv) closeNameModal(); });
nameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); saveUsernameFromInput(); } });
nameSave.onclick = ()=> saveUsernameFromInput();

btnRanking.onclick = ()=>{
  renderRanking();
  rankOv.style.display='flex';
  refreshLeaderboard({ showSpinner:false });
};
rankClose.onclick = ()=>{ rankOv.style.display='none'; };
rankRefreshBtn.onclick = ()=> refreshLeaderboard({ showSpinner:true });

// ====== HUD / ä¾¿åˆ© ======
function hearts(n){ return 'â¤ï¸'.repeat(n) + 'â™¡'.repeat(3-n); }
function setHUD(remainMs){
  const sec = Math.max(0, Math.ceil(remainMs/1000));
  const invActive = now()<invUntil;
  const st = stageForLevel(level).name;
  const ch = characters[currentCharKey];
  const own = collection.owned[currentCharKey];
  const lb = own?.limit? own.limit : 0;
  const best = rankings.length ? rankings[0].score.toLocaleString('ja-JP') : 0;
  const scoreText = score.toLocaleString('ja-JP');
  const coinText = coins.toLocaleString('ja-JP');
  hud.innerHTML = `
    <div class="hudRow">
      <span class="hudItem"><strong>ã‚¹ãƒ†ãƒ¼ã‚¸</strong><span class="value">${st}</span></span>
      <span class="hudItem"><strong>ãƒ¬ãƒ™ãƒ«</strong><span class="value">${level}</span></span>
      <span class="hudItem"><strong>æ®‹ã‚Š</strong><span class="value">${sec}ç§’</span></span>
      ${invActive ? '<span class="hudItem"><span class="hudTag">ç„¡æ•µä¸­</span></span>' : ''}
    </div>
    <div class="hudRow">
      <span class="hudItem hudHearts"><strong>ãƒ©ã‚¤ãƒ•</strong><span class="value">${hearts(lives)}</span></span>
      <span class="hudItem"><strong>ã‚¹ã‚³ã‚¢</strong><span class="value">${scoreText}</span></span>
      <span class="hudItem hudCoins"><strong>ã‚³ã‚¤ãƒ³</strong><span class="value">ğŸª™${coinText}</span></span>
      <span class="hudItem"><strong>å¿…æ®º</strong><span class="value">${Math.floor(ult)}%</span></span>
      <span class="hudItem"><strong>ãƒ™ã‚¹ãƒˆ</strong><span class="value">${best}</span></span>
    </div>`;
  charInfo.textContent = `CHAR: ${ch.emoji} ${ch.name} [${ch.rar}]  LB:${lb}`;
  btnUlt.style.display = ultReady ? 'block':'none';
  btnGacha.disabled = coins < 10;
  btnGacha10.disabled = coins < 100;
}

function refreshHUD(){
  const remain = gameOn ? (GAME_TIME - (now()-t0)) : 0;
  setHUD(remain);
}
const now = ()=>performance.now();
const rand = (a,b)=> a + Math.random()*(b-a);
const AABB = (a,b)=> a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));

// ====== ã‚¹ãƒãƒ¼ãƒ³ ======
function spawnItem(){
  const isParfait = Math.random()<0.5;
  items.push({
    x: cv.width+24,
    y: cv.height - GROUND - 44 - rand(0, 95),
    w: 30, h: 30,
    v: 3.0 + rand(.6,1.8) + (level-1)*.22,
    char: isParfait ? 'ğŸ¨' : 'ğŸŸ',
    score: isParfait ? 2 : 1
  });
}
function spawnEnemy(){
  const st = stageForLevel(level);
  enemies.push({
    x: cv.width+30,
    y: cv.height - GROUND - 36,
    w: 36, h: 36,
    v: (2.7 + (level-1)*.35) * st.enemyMul
  });
}
function spawnPower(){
  powers.push({
    x: cv.width+26,
    y: cv.height - GROUND - 44 - rand(0, 120),
    w: 26, h: 26,
    v: 3.0 + (level-1)*.25
  });
}

// ====== å…¥åŠ› ======
let canDouble = false, guardReadyTime = 0;
function jump(){
  if (!gameOn) return;
  // äºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—åˆ¤å®š
  const hasDouble = characters[currentCharKey].special?.includes('doubleJump');
  if (player.onGround){
    player.vy = currentStats.jump; player.onGround=false;
    canDouble = hasDouble; // åœ°ä¸Šé›¢é™¸æ™‚ã«2æ®µç›®æ¨©åˆ©ä»˜ä¸
  } else if (hasDouble && canDouble){
    player.vy = currentStats.jump * 0.9; // 2æ®µç›®ã¯ã‚„ã‚„å¼±ã‚
    canDouble = false;
  }
}
function shoot(){
  if (!gameOn) return;
  const t=now(); if (t-lastShot<shootCD) return; lastShot=t;
  const pierce = characters[currentCharKey].special?.includes('pierce');
  const v = 9+level*.6 + (now()<bulletBoostUntil? 4:0);
  bullets.push({ x:player.x+player.w, y:player.y+player.h/2-3, w:12, h:6, v: v*currentStats.bullet, hitsLeft: pierce? 2 : 1 });
}
function tryUlt(){
  if (!gameOn||!ultReady) return;
  ultReady=false; ult=0;
  const type = characters[currentCharKey].ult;
  ultProjectiles.length = 0;
  if (type==='storm') {
    ultActiveUntil = now()+1600;
  } else if (type==='ncha') {
    ultActiveUntil = now()+1500;
  } else if (type==='yadon') {
    ultActiveUntil = now()+2600;
    const baseY = player.y + player.h/2;
    const count = 6;
    for (let i=0;i<count;i++){
      const spread = i - (count-1)/2;
      ultProjectiles.push({
        x: player.x + player.w - 8,
        y: baseY + spread*20,
        w: 32,
        h: 32,
        vx: 5.4 + Math.abs(spread)*0.6,
        vy: spread*0.28,
        gravity: 0.08,
        hits: 2,
        char: 'ğŸ¦›',
        expires: now()+2800,
        dead: false,
      });
    }
  } else {
    ultActiveUntil = now()+2000; // rainbowãƒ‡ãƒ•ã‚©
  }
}

// PCã‚­ãƒ¼
window.addEventListener('keydown', e=>{
  if (e.code==='Space' || e.code==='ArrowUp') jump();
  if (e.key==='z'||e.key==='x'||e.key==='Z'||e.key==='X') shoot();
  if (e.key==='c' || e.key==='C') tryUlt();
});

// ã‚¿ãƒƒãƒï¼ˆå·¦ï¼ã‚¸ãƒ£ãƒ³ãƒ—ã€å³ï¼æ”»æ’ƒ or é•·æŠ¼ã—ã§å¿…æ®ºï¼‰
let pressTimer=null, pressedRight=false;
cv.addEventListener('touchstart', e=>{
  e.preventDefault();
  const rect=cv.getBoundingClientRect();
  const x=e.changedTouches[0].clientX - rect.left;
  const isLeft = x < rect.width/2;
  if (isLeft){ jump(); pressedRight=false; }
  else {
    pressedRight=true;
    pressTimer=setTimeout(()=>{ if(pressedRight) tryUlt(); }, 350);
    shoot();
  }
},{passive:false});
cv.addEventListener('touchend', ()=>{ pressedRight=false; clearTimeout(pressTimer); }, {passive:true});
btnUlt.addEventListener('click', tryUlt);

// ====== ã‚­ãƒ£ãƒ©é©ç”¨ ======
let currentStats = getEffectiveStats(currentCharKey);
function getEffectiveStats(key){
  // åŸºæœ¬
  const ch = characters[key];
  const lb = collection.owned[key]?.limit || 0; // å°æ•°ã®ç´¯ç©
  // é™ç•Œçªç ´ã¶ã‚“ã‚’ç­‰å€å¢—åŠ ï¼ˆä¾‹ï¼š+0.03 ãªã‚‰ +3%ï¼‰
  return {
    move:   ch.move   * (1+lb),
    jump:   BASE_JUMP * ch.jump * (1+lb*0.5), // ã‚¸ãƒ£ãƒ³ãƒ—ã¯æ§ãˆã‚ã«åæ˜ 
    bullet: ch.bullet * (1+lb),
    inv:    Math.floor(ch.inv * (1+lb*0.5)),
    ultRate:ch.ultRate* (1+lb*0.5),
    special: ch.special,
    ult: ch.ult,
  };
}
function setCurrentChar(key){
  currentCharKey = key;
  collection.current = key;
  saveCollection();
  currentStats = getEffectiveStats(key);
  updateCharInfo();
}
function updateCharInfo(){
  const ch = characters[currentCharKey];
  const own = collection.owned[currentCharKey];
  const lb = own?.limit? own.limit : 0;
  charInfo.textContent = `CHAR: ${ch.emoji} ${ch.name} [${ch.rar}]  LB:${lb}`;
}

// ====== æ›´æ–° ======
function update(t){
  if(!gameOn) return;
  const elapsed=t-t0, remain=GAME_TIME-elapsed;
  if (remain<=0) return endGame();

  // ãƒ¬ãƒ™ãƒ«
  level = Math.max(1, Math.floor(score/itemLv)+1);
  const st = stageForLevel(level);

  // ç”Ÿæˆé–“éš”
  const itemIv  = clamp(1200 - (level-1)*100, 480, 1200);
  const enemyIv = clamp(1650 - (level-1)*130, 600, 1650);
  const powerIv = 6200;

  if(t-lastItem  > itemIv)  { spawnItem();  lastItem=t; }
  if(t-lastEnemy > enemyIv) { spawnEnemy(); lastEnemy=t; }
  if(t-lastPower > powerIv) { spawnPower(); lastPower=t; }

  // ç‰©ç†
  player.vy += G; player.y += player.vy;
  if (player.y+player.h >= cv.height-GROUND){
    player.y=cv.height-GROUND-player.h; player.vy=0; player.onGround=true; canDouble = characters[currentCharKey].special?.includes('doubleJump');
  }

  // ã‚ªãƒ¼ãƒˆå°„æ’ƒï¼ˆã‚¬ãƒãƒ£åŠ¹æœãªã©å°†æ¥ç”¨ï¼‰
  if (now()<autoShootUntil && t-lastShot>shootCD*0.6){ shoot(); }

  // å¼¾
  bullets = bullets.filter(b=> {
    b.x += b.v;
    return (b.x < cv.width+24) && b.hitsLeft>0;
  });

  // ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆMythic magnetï¼‰
  const hasMagnet = characters[currentCharKey].special?.includes('magnet');
  items = items.filter(it=>{
    // å¸å¼•
    if (hasMagnet){
      const dx = (player.x - it.x), dy = (player.y - it.y);
      const dist = Math.hypot(dx,dy);
      if (dist < 160){
        it.x += dx*0.18; it.y += dy*0.18;
      }
    }
    it.x -= it.v;
    if (AABB(player,it)){
      const mul = now()<scoreMulUntil ? 2 : 1;
      score += it.score*mul; coins += 1 * mul;
      ult = clamp(ult + (it.char==='ğŸ¨'?10:6) * currentStats.ultRate, 0, 100);
      return false;
    }
    return it.x+it.w>0;
  });

  // â­
  powers = powers.filter(pw=>{
    pw.x -= pw.v;
    if (AABB(player,pw)){ invUntil=now()+Math.max(powerMillis,currentStats.inv); ult=Math.min(100,ult+12*currentStats.ultRate); return false; }
    return pw.x+pw.w>0;
  });

  // å¿…æ®ºæŠ•å°„ä½“ï¼ˆãƒ¤ãƒ‰ãƒ³ç ²ï¼‰
  ultProjectiles.forEach(p=>{
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
  });

  // å¿…æ®ºæº–å‚™
  if (ult>=100) ultReady=true;

  // æ•µ
  const hasSlow = characters[currentCharKey].special?.includes('slowEnemy');
  enemies = enemies.filter(en=>{
    en.x -= en.v;

    // å¿…æ®º
    if (now()<ultActiveUntil){
      const type = characters[currentCharKey].ult;
      if (type==='storm'){
        // æ¸¦ï¼šåŠå¾„120
        const cx = player.x+player.w/2, cy = player.y+player.h/2;
        const ex = en.x+en.w/2, ey = en.y+en.h/2;
        const hit = Math.hypot(cx-ex, cy-ey) <= 120;
        if (hit){ score+=enemyBonus; coins+=2; return false; }
      } else if (type==='ncha'){
        // ã‚“ã¡ã‚ƒç ²ï¼šå‰æ–¹ãƒ“ãƒ¼ãƒ 
        const beamX = player.x + player.w - 6;
        const beamTop = player.y - 36;
        const beamBottom = player.y + player.h + 36;
        const hit = (en.x+en.w) >= beamX && en.x <= cv.width && en.y <= beamBottom && (en.y+en.h) >= beamTop;
        if (hit){ score+=enemyBonus; coins+=2; return false; }
      } else {
        // rainbowï¼š3ãƒ¬ãƒ¼ãƒ³
        const lanes = [player.y + player.h/2, player.y + player.h/2 - 36, player.y + player.h/2 + 36];
        const hit = lanes.some(y=> en.y-6 <= y && y <= en.y+en.h+6);
        if (hit){ score+=enemyBonus; coins+=2; return false; }
      }
    }

    if (characters[currentCharKey].ult==='yadon'){
      for (let i=0;i<ultProjectiles.length;i++){
        const shot = ultProjectiles[i];
        if (!shot || shot.dead) continue;
        if (AABB(en, shot)){
          score+=enemyBonus; coins+=2;
          shot.hits--;
          if (shot.hits<=0) shot.dead=true;
          return false;
        }
      }
    }

    // å¼¾ãƒ’ãƒƒãƒˆï¼ˆpierceå¯¾å¿œï¼‰
    for (let i=0;i<bullets.length;i++){
      if (AABB(en,bullets[i])){
        score+=enemyBonus; coins+=2;
        bullets[i].hitsLeft--;
        if (hasSlow) en.v *= 0.6; // ä¸€æ™‚çš„ã‚¹ãƒ­ãƒ¼ï¼ˆç°¡æ˜“ï¼‰
        if (bullets[i].hitsLeft<=0) bullets.splice(i,1);
        return false;
      }
    }

    // ä½“å½“ãŸã‚Š
    if (AABB(player,en)){
      if (now()<invUntil){ score+=enemyBonus; coins+=2; return false; }
      // oneGuardï¼ˆ7ç§’CDï¼‰
      const hasGuard = characters[currentCharKey].special?.includes('oneGuard');
      if (hasGuard && now() - guardReadyTime > 7000){
        guardReadyTime = now(); // ãƒãƒ¼ãƒ€ãƒ¡ã§å®ˆã‚‹
        return false;
      }
      if (now()>hurtUntil){
        lives=Math.max(0,lives-1); hurtUntil=now()+900;
        if (lives===0){ endGame(); return false; }
      }
    }
    return en.x+en.w>0;
  });

  ultProjectiles = ultProjectiles.filter(p=> !p.dead && now()<p.expires && p.x<cv.width+60 && p.y>-80 && p.y<cv.height+80 && p.hits>0);

  draw(remain, st);
  requestAnimationFrame(update);
}

// ====== æç”» ======
function draw(remain, st){
  const g=c.createLinearGradient(0,0,0,cv.height);
  g.addColorStop(0, st.bg1); g.addColorStop(1, st.bg2);
  c.fillStyle=g; c.fillRect(0,0,cv.width,cv.height);
  c.fillStyle=st.ground; c.fillRect(0, cv.height-GROUND, cv.width, GROUND);

  if (now()<invUntil){ c.strokeStyle='#f5c542'; c.lineWidth=4; c.strokeRect(player.x-2,player.y-2,player.w+4,player.h+4); }
  const blink = now()<hurtUntil && Math.floor(now()/60)%2===0;
  if (!blink){ c.fillStyle=player.color; c.fillRect(player.x,player.y,player.w,player.h); }

  // å¿…æ®ºæç”»
  if (now()<ultActiveUntil){
    const type = characters[currentCharKey].ult;
    if (type==='storm'){
      const cx = player.x+player.w/2, cy = player.y+player.h/2;
      c.fillStyle='rgba(80,160,255,.25)'; c.beginPath(); c.arc(cx,cy,120,0,Math.PI*2); c.fill();
      c.strokeStyle='rgba(200,230,255,.7)'; c.lineWidth=3; c.beginPath(); c.arc(cx,cy,88,0,Math.PI*2); c.stroke();
    } else if (type==='ncha'){
      const beamX = player.x + player.w - 6;
      const beamTop = player.y - 36;
      const beamH = player.h + 72;
      const intensity = 0.45 + 0.25 * ((Math.sin(now()/90)+1)/2);
      c.fillStyle=`rgba(255,235,59,${intensity})`; c.fillRect(beamX, beamTop, cv.width-beamX, beamH);
      c.fillStyle='rgba(255,255,255,0.8)'; c.fillRect(beamX, beamTop + beamH/2 - 6, cv.width-beamX, 12);
    } else if (type==='yadon'){
      const auraPulse = 40 + Math.sin(now()/140)*6;
      c.strokeStyle='rgba(255,192,203,0.7)';
      c.lineWidth=6;
      c.beginPath(); c.arc(player.x+player.w/2, player.y+player.h/2, auraPulse, 0, Math.PI*2); c.stroke();
    } else {
      const laneYs = [player.y + player.h/2, player.y + player.h/2 - 36, player.y + player.h/2 + 36];
      laneYs.forEach((y,idx)=>{
        c.fillStyle=`rgba(${180+idx*25},${80+idx*50},255,.65)`; c.fillRect(player.x, y-6, cv.width-player.x, 12);
        c.fillStyle='rgba(255,255,255,.55)'; c.fillRect(player.x, y-2, cv.width-player.x, 4);
      });
    }
  }

  // å¼¾
  c.fillStyle='#333'; bullets.forEach(b=> c.fillRect(b.x,b.y,b.w,b.h));

  // ã‚¢ã‚¤ãƒ†ãƒ 
  c.font='28px serif'; c.textBaseline='top';
  items.forEach(it=> c.fillText(it.char,it.x,it.y));

  // ãƒ¤ãƒ‰ãƒ³ç ²ã®ç¾¤ã‚Œ
  if (ultProjectiles.length){
    c.font='32px serif';
    ultProjectiles.forEach(p=>{
      const fade = Math.max(0.35, Math.min(1, (p.expires - now())/400));
      c.save();
      c.globalAlpha = fade;
      c.fillText(p.char, p.x, p.y);
      c.restore();
    });
  }

  // â­
  powers.forEach(pw=>{ c.font='26px serif'; c.fillText('â­', pw.x, pw.y); });

  // æ•µ
  enemies.forEach(en=>{ c.font='32px serif'; c.fillText('ğŸ‘¾', en.x, en.y-4); });

  setHUD(remain);
}

// ====== é–‹å§‹/çµ‚äº† ======
function startGame(){
  if (!username){
    openNameModal();
    return;
  }
  score=0; level=1; lives=3; invUntil=0; hurtUntil=0; ult=0; ultReady=false; ultActiveUntil=0;
  coins=0; autoShootUntil=0; bulletBoostUntil=0; scoreMulUntil=0;
  items.length=0; enemies.length=0; bullets.length=0; powers.length=0; ultProjectiles.length=0;
  player.x=120; player.y=cv.height-GROUND-player.h; player.vy=0; player.onGround=true;
  canDouble = characters[currentCharKey].special?.includes('doubleJump');
  guardReadyTime = 0;
  btnStart.style.display='none'; btnRestart.style.display='none';
  t0=now(); gameOn=true;
  lastItem=lastEnemy=lastPower=lastShot=t0;
  currentStats = getEffectiveStats(currentCharKey);
  setHUD(GAME_TIME); draw(GAME_TIME, stageForLevel(level));
  requestAnimationFrame(update);
}
function endGame(){
  if(!gameOn) return; gameOn=false;
  const st = stageForLevel(level);
  draw(0, st);
  c.fillStyle='rgba(0,0,0,.55)'; c.fillRect(0,0,cv.width,cv.height);
  c.fillStyle='#fff'; c.textAlign='center';
  c.font='36px sans-serif'; c.fillText('ã‚²ãƒ¼ãƒ çµ‚äº†ï¼', cv.width/2, cv.height/2 - 24);
  c.font='24px sans-serif'; c.fillText(`æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score}ã€€ãƒ¬ãƒ™ãƒ«: ${level}ã€€ã‚³ã‚¤ãƒ³: ğŸª™${coins}`, cv.width/2, cv.height/2 + 10);
  recordRanking({ score, level, coins, char: currentCharKey, time: Date.now() });
  c.textAlign='start'; btnRestart.style.display='inline-block';
}

// ====== ãƒœã‚¿ãƒ³ ======
btnStart.addEventListener('click', startGame);
btnRestart.addEventListener('click', startGame);

btnHow.addEventListener('click', ()=>{
  alert(
    'â–¶ åŸºæœ¬ãƒ«ãƒ¼ãƒ«\n' +
    'ãƒ»ã‚¹ã‚¿ãƒ¼ãƒˆã§60ç§’ãƒ©ãƒ³é–‹å§‹ã€‚æ•µã‚’é¿ã‘ã¤ã¤ğŸ¨ã‚„ğŸŸã‚’é›†ã‚ã¦ã‚¹ã‚³ã‚¢ã‚’ä¼¸ã°ãã†ã€‚\n' +
    'ãƒ»ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ã¨ãƒ©ã‚¤ãƒ•æ¸›ã€‚ã‚¼ãƒ­ã«ãªã‚‹ã¨ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚\n\n' +
    'â–¶ æ“ä½œï¼ˆã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹å…±é€šï¼‰\n' +
    'ãƒ»ç”»é¢å·¦ã‚¿ãƒƒãƒ—ï¼šã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆå¯¾å¿œã‚­ãƒ£ãƒ©ã¯äºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—å¯ï¼‰ã€‚\n' +
    'ãƒ»ç”»é¢å³ã‚¿ãƒƒãƒ—ï¼šæ”»æ’ƒã€‚å³é•·æŠ¼ã— or å³ä¸‹ã€Œå¿…æ®ºã€ã§ã‚²ãƒ¼ã‚¸100%æ™‚ã«å¿…æ®ºæŠ€ã€‚\n' +
    'ãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼šSpace/â†‘ï¼ã‚¸ãƒ£ãƒ³ãƒ—ã€Z/Xï¼æ”»æ’ƒã€Cï¼å¿…æ®ºæŠ€ã€‚\n\n' +
    'â–¶ ã‚³ã‚¤ãƒ³ã¨ã‚¬ãƒãƒ£\n' +
    'ãƒ»æ•µæ’ƒç ´ã‚„ã‚¢ã‚¤ãƒ†ãƒ ã§ã‚³ã‚¤ãƒ³ç²å¾—ã€‚1å›10ã‚³ã‚¤ãƒ³ã€10é€£100ã‚³ã‚¤ãƒ³ã€‚\n' +
    'ãƒ»30é€£ã§ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰ä¿è¨¼ / 100é€£ã§ãƒŸã‚·ãƒƒã‚¯ä¿è¨¼ã€‚\n\n' +
    'â–¶ ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³\n' +
    'ãƒ»å¼•ã„ãŸã‚­ãƒ£ãƒ©ã¯è‡ªå‹•ç™»éŒ²ã€‚é‡è¤‡ã§é™ç•Œçªç ´ã—ã¦æ€§èƒ½ãŒå°‘ã—ã‚¢ãƒƒãƒ—ã€‚\n' +
    'ãƒ»è£…å‚™ã—ãŸã‚­ãƒ£ãƒ©ã®ç‰¹æ€§ã‚„å¿…æ®ºã‚’æ´»ã‹ã—ã¦ãƒã‚¤ã‚¹ã‚³ã‚¢ã‚’ç‹™ãŠã†ï¼\n\n' +
    'â–¶ Legendaryã‚­ãƒ£ãƒ©\n' +
    'ãƒ»ğŸ‘‘ã‚­ãƒ³ã‚°ï¼šè™¹ãƒ¬ãƒ¼ã‚¶ãƒ¼ã€‚\n' +
    'ãƒ»ğŸ¤–ã‚“ã¡ã‚ƒãƒã‚·ãƒ³ï¼šã‚“ã¡ã‚ƒç ²ã€‚\n' +
    'â–¶ Mythicã‚­ãƒ£ãƒ©\n' +
    'ãƒ»ğŸŒˆã‚ªãƒ¼ãƒ­ãƒ©ï¼šå¸å¼•ï¼‹ä¸€åº¦ã ã‘ã‚¬ãƒ¼ãƒ‰ã€‚å¿…æ®ºã¯ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ¬ãƒ¼ã‚¶ãƒ¼ã€‚\n' +
    'ãƒ»ğŸŒ€é°¯ç‹ï¼šäºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—ï¼‹è²«é€šå¼¾ã€‚å¿…æ®ºã¯ãƒˆãƒ«ãƒãƒ¼ãƒ‰æ”»æ’ƒã€‚\n' +
    'ãƒ»ğŸ¦›ãƒ¤ãƒ‰ãƒ³ï¼šãƒ¤ãƒ‰ãƒ³ç ²ã€‚'
  );
});

// ====== ã‚¹ãƒãƒ¼ãƒ³ã¨æ”»æ’ƒãƒˆãƒªã‚¬ ======
function shootIfAuto(t){ /* äºˆå‚™ãƒ•ãƒƒã‚¯ */ }

// ====== ã‚¬ãƒãƒ£ãƒœã‚¿ãƒ³ ======
btnGacha.onclick = ()=> doGacha(1);
btnGacha10.onclick = ()=> doGacha(10);

function renderRanking(){
  if (!rankList) return;
  rankList.innerHTML='';
  if (isRankingLoading){
    const loading=document.createElement('li');
    loading.className='rankEmpty';
    loading.textContent='ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦';
    rankList.appendChild(loading);
    return;
  }
  if (rankingError){
    const err=document.createElement('li');
    err.className='rankEmpty';
    err.textContent=rankingError;
    rankList.appendChild(err);
    return;
  }
  if (!rankings.length){
    const empty=document.createElement('li');
    empty.className='rankEmpty';
    empty.textContent='ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“';
    rankList.appendChild(empty);
    return;
  }
  rankings.forEach((r, idx)=>{
    const ch = characters[r.char] || {};
    const li=document.createElement('li');
    const left=document.createElement('div');
    left.className='rankLeft';
    const head=document.createElement('div');
    head.className='rankHeader';
    const no=document.createElement('span');
    no.className='rankNo';
    no.textContent=`${idx+1}`;
    const user=document.createElement('span');
    user.textContent=r.name || '???';
    const titleParts=[ch.emoji||'', ch.name||r.char].filter(Boolean);
    const displayName=titleParts.join(' ').trim() || '???';
    head.appendChild(no);
    head.appendChild(user);
    left.appendChild(head);
    const meta=document.createElement('div');
    meta.className='rankMeta';
    meta.textContent=`${formatRankDate(r.time)} / ã‚­ãƒ£ãƒ©:${displayName} / ãƒ¬ãƒ™ãƒ«:${r.level} / ã‚³ã‚¤ãƒ³:ğŸª™${r.coins}`;
    left.appendChild(meta);
    const score=document.createElement('div');
    score.className='rankScore';
    score.textContent=r.score.toLocaleString('ja-JP');
    li.appendChild(left);
    li.appendChild(score);
    rankList.appendChild(li);
  });
}

async function recordRanking(entry){
  if (!entry || typeof entry.score!=='number') return;
  if (!username){
    rankingError='ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚';
    renderRanking();
    return;
  }
  const safe = normalizeEntry({
    score: entry.score,
    level: entry.level,
    coins: entry.coins,
    char: entry.char,
    name: username,
    time: entry.time
  });
  rankings = mergeRankings([...rankings, safe]);
  renderRanking();
  refreshHUD();
  try{
    const res = await fetch(apiUrl('leaderboard'), {
      method:'POST',
      headers:{'Content-Type':'application/json','Accept':'application/json'},
      body: JSON.stringify({
        name: safe.name,
        score: safe.score,
        level: safe.level,
        coins: safe.coins,
        char: safe.char
      })
    });
    if (!res.ok) throw new Error(`bad status ${res.status}`);
    const data = await res.json();
    const list = Array.isArray(data?.leaderboard) ? data.leaderboard : data;
    if (Array.isArray(list)){
      rankings = mergeRankings(list);
      rankingError='';
      renderRanking();
      refreshHUD();
    }
  }catch(err){
    console.warn('Failed to submit score', err);
    rankingError='ã‚¹ã‚³ã‚¢é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
    renderRanking();
  }
}

// ====== ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ ======
function loadCollection(){
  try{
    const s = localStorage.getItem(STORE_KEY);
    if (s) return JSON.parse(s);
  }catch{}
  return { current:'parfen', owned: { parfen:{owned:true,dup:0,limit:0} } };
}
function saveCollection(){ try{ localStorage.setItem(STORE_KEY, JSON.stringify(collection)); }catch{} }
function loadPity(){
  try{ const s = localStorage.getItem(pityKey); if(s) return JSON.parse(s); }catch{}
  return { sinceL:0, sinceM:0 };
}
function savePity(){ try{ localStorage.setItem(pityKey, JSON.stringify(pity)); }catch{} }

function loadUsername(){
  try{
    const s = localStorage.getItem(USERNAME_KEY);
    if (typeof s === 'string'){
      return sanitizeUsername(s);
    }
  }catch{}
  return '';
}

function saveUsername(){
  try{ localStorage.setItem(USERNAME_KEY, username); }catch{}
}

function updateNameUI(){
  if (username){
    playerNameLabel.textContent = `ãƒ¦ãƒ¼ã‚¶ãƒ¼å: ${username}`;
    playerNameLabel.classList.remove('muted');
    btnEditName.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å¤‰æ›´';
    btnStart.disabled = false;
    btnRestart.disabled = false;
  } else {
    playerNameLabel.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼åæœªè¨­å®š';
    playerNameLabel.classList.add('muted');
    btnEditName.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’è¨­å®š';
    btnStart.disabled = true;
    btnRestart.disabled = true;
  }
}

function openNameModal(){
  nameInput.value = username;
  nameError.textContent='';
  nameOv.style.display='flex';
  setTimeout(()=> nameInput.focus(), 50);
}

function closeNameModal(){
  nameOv.style.display='none';
}

function saveUsernameFromInput(){
  const sanitized = sanitizeUsername(nameInput.value);
  const validation = validateUsername(sanitized);
  if (validation){
    nameError.textContent = validation;
    return;
  }
  username = sanitized;
  saveUsername();
  updateNameUI();
  rankingError='';
  renderRanking();
  refreshLeaderboard({ showSpinner:false });
  closeNameModal();
}

function sanitizeUsername(raw){
  if (typeof raw!=='string') return '';
  return raw.replace(/[\s\uFEFF\u200B]+/g,' ').trim();
}

function validateUsername(name){
  if (!name) return '2æ–‡å­—ä»¥ä¸Š16æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
  if (name.length < 2) return '2æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
  if (name.length > 16) return '16æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
  return '';
}

function apiUrl(path){
  const rawPath = typeof path === 'string' ? path : '';
  if (/^https?:\/\//i.test(rawPath)) return rawPath;
  const safeBase = (typeof API_BASE === 'string' && API_BASE.length > 0) ? API_BASE : DEFAULT_API_BASE;
  try{
    const baseUrl = new URL(safeBase, window.location.href);
    const finalUrl = new URL(baseUrl.toString());
    const trimmedPath = rawPath.trim();
    if (!trimmedPath){
      return finalUrl.toString();
    }
    const dummy = new URL(trimmedPath.replace(/^\/+/, ''), 'https://placeholder/');
    const cleanPath = dummy.pathname.replace(/^\/+|\/+$/g, '');
    const basePath = baseUrl.pathname.replace(/\/+$/g, '');
    const combinedPath = cleanPath
      ? [basePath, cleanPath].filter(Boolean).join('/')
      : basePath;
    const normalizedPath = combinedPath
      ? (combinedPath.startsWith('/') ? combinedPath : `/${combinedPath}`)
      : '/';
    finalUrl.pathname = normalizedPath;

    const mergedSearch = new URLSearchParams(baseUrl.search);
    const extraSearch = new URLSearchParams(dummy.search);
    const baseHashParams = new URLSearchParams(baseUrl.hash ? baseUrl.hash.replace(/^#/, '') : '');
    const dummyHashParams = new URLSearchParams(dummy.hash ? dummy.hash.replace(/^#/, '') : '');
    for (const [key, value] of extraSearch.entries()){
      mergedSearch.append(key, value);
    }
    for (const [key, value] of baseHashParams.entries()){
      mergedSearch.append(key, value);
    }
    for (const [key, value] of dummyHashParams.entries()){
      mergedSearch.append(key, value);
    }
    const searchString = mergedSearch.toString();
    finalUrl.search = searchString ? `?${searchString}` : '';
    finalUrl.hash = dummy.hash || baseUrl.hash;
    return finalUrl.toString();
  }catch(err){
    console.warn('Invalid API base URL', API_BASE, err);
    return rawPath || safeBase;
  }
}

async function refreshLeaderboard(opts){
  if (isRankingLoading) return;
  const showSpinner = opts?.showSpinner ?? (rankings.length === 0);
  isRankingLoading = true;
  rankingError = '';
  if (showSpinner) renderRanking();
  try{
    const res = await fetch(apiUrl(`leaderboard?limit=${RANK_MAX}`), { headers:{'Accept':'application/json'} });
    if (!res.ok) throw new Error(`bad status ${res.status}`);
    const data = await res.json();
    const list = Array.isArray(data?.leaderboard) ? data.leaderboard : data;
    if (Array.isArray(list)){
      rankings = mergeRankings(list);
      rankingError = '';
    } else {
      rankings = [];
    }
  }catch(err){
    console.warn('Failed to load leaderboard', err);
    rankingError = 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
  }finally{
    isRankingLoading = false;
    renderRanking();
    refreshHUD();
  }
}

function normalizeEntry(entry){
  const safeTime = Number(entry?.time);
  const safeScore = Math.max(0, Math.floor(Number(entry?.score)||0));
  const safeLevel = Math.max(1, Math.floor(Number(entry?.level)||0));
  const safeCoins = Math.max(0, Math.floor(Number(entry?.coins)||0));
  const safeChar = typeof entry?.char === 'string' ? entry.char : 'parfen';
  const safeName = sanitizeUsername(entry?.name||'') || '???';
  return {
    score: safeScore,
    level: safeLevel,
    coins: safeCoins,
    char: safeChar,
    name: safeName,
    time: Number.isFinite(safeTime) ? safeTime : Date.now()
  };
}

function mergeRankings(list){
  return list
    .filter(r=> typeof r?.score === 'number')
    .map(normalizeEntry)
    .sort((a,b)=>{
      if (b.score !== a.score) return b.score - a.score;
      return a.time - b.time;
    })
    .slice(0, RANK_MAX);
}
function formatRankDate(ts){
  const d = new Date(ts||Date.now());
  const y = d.getFullYear();
  const m = pad2(d.getMonth()+1);
  const day = pad2(d.getDate());
  const h = pad2(d.getHours());
  const min = pad2(d.getMinutes());
  return `${y}/${m}/${day} ${h}:${min}`;
}
function pad2(n){ return `${n}`.padStart(2,'0'); }

// ====== åˆæœŸHUD ======
setHUD(GAME_TIME);
updateCharInfo();
})();
</script>
</body>
</html>
